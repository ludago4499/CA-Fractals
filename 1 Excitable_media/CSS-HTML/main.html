<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title> Greenberg Hastings</title>
    <link href="styles.css" rel="stylesheet" />
</head>
<body>
    <h1>Greenberg Hastings Model</h1>
    <div id = "content">
        <form id="formCoords" aria-label="Lista de coordenadas">
            <h2>Coordinates for Cells</h2>
            <div class="row">
                <label>
                    Tipo
                    <select id="cellType" aria-label="Tipo de celda">
                        <option value="excitable">Excitable</option>
                        <option value="refracted">Refracted</option>
                    </select>
                </label>
            </div>
            
            <div class="row">
                <label>
                    X
                    <input id="x" name="x" type="number" step="1" min="-50" max="50" required placeholder="ej. 50">
                </label>
                <label>
                    Y
                    <input id="y" name="y" type="number" step="1" min="-50" max="50" required placeholder="ej. 50">
                </label>
            </div>

            

            <div class="row">
                <button type="submit">Add</button>
                <button type="button" id="clear">Clear</button>
                <button type="button" id="start">Start</button>
            </div>

            <div class="row" id = "listsContainer">
                <div>
                    <h3>Excitable</h3>
                    <ul id="coordsExcitableList" aria-live="polite"></ul>
                </div>
                <div>
                    <h3>Refracted</h3>
                    <ul id="coordsRefractedList" aria-live="polite"></ul>
                </div>
            </div>
        </form>
        <canvas id="fractalCanvas" width="1200" height="800"></canvas>
    </div>
    

    <script>
        const coordsExcitable = [];
        const coordsRefracted = [];
        const form = document.getElementById('formCoords');
        const inputX = document.getElementById('x');
        const inputY = document.getElementById('y');
        const typeSelect = document.getElementById('cellType');
        const excitableList = document.getElementById('coordsExcitableList');
        const refractedList = document.getElementById('coordsRefractedList');
        const clearBtn = document.getElementById('clear');
        const sendBtn = document.getElementById('start');

        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const API_URL = 'http://localhost:8000';

        let animationId = null;
        let simulation = false;

        function render() {
            excitableList.innerHTML = '';
            refractedList.innerHTML = '';

            coordsExcitable.forEach((c, i) => {
                const li = document.createElement('li');
                li.textContent = `(${c.x}, ${c.y})`;
                excitableList.appendChild(li);
            });

            coordsRefracted.forEach((c, i) => {
                const li = document.createElement('li');
                li.textContent = `(${c.x}, ${c.y})`;
                refractedList.appendChild(li);
            });
        }

        form.addEventListener('submit', e => {
            e.preventDefault();
            const xv = parseFloat(inputX.value);
            const yv = parseFloat(inputY.value);
            if (!Number.isFinite(xv) || !Number.isFinite(yv)) {
                alert('Ingrese valores numéricos válidos.');
                return;
            }

            const type = typeSelect.value;
            if (type === 'excitable') {
                coordsExcitable.push({ x: xv, y: yv });
            } else {
                coordsRefracted.push({ x: xv, y: yv });
            }

            inputX.value = '';
            inputY.value = '';
            inputX.focus();
            render();
            console.log('Excitable:', coordsExcitable, 'Refracted:', coordsRefracted);
        });

        clearBtn.addEventListener('click', () => {
            simulation = false;
            if (animationId) cancelAnimationFrame(animationId);

            coordsExcitable.length = 0;
            coordsRefracted.length = 0;
            render();

            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            inputX.focus();
        });

        async function animar() {
            if (!simulation) return;

            try {
                // 1. Pedir siguiente paso
                const res = await fetch(`${API_URL}/step`);
                if (!res.ok) throw new Error("Error obteniendo step");
                
                const data = await res.json();

                // 2. Dibujar
                dibujarGrid(data);
                    setTimeout(() => {
                    // Solo pedimos el siguiente frame si la simulación sigue activa
                    if (simulation) {
                        animationId = requestAnimationFrame(animar);
                    }
                }, 2000);
                
                // 3. Repetir
                animationId = requestAnimationFrame(animar);

            } catch (err) {
                console.error("Error en animación:", err);
                simulation = false; // Detener en caso de error
            }
        }
        
        sendBtn.addEventListener('click', async () => {
            if (coordsExcitable.length === 0 && coordsRefracted.length === 0) {
                alert('Ambas listas están vacías.');
                return;
            }
            simulation = false;
            if(animationId) cancelAnimationFrame(animationId);

            try {
                const payload = { excitable: coordsExcitable, refracted: coordsRefracted };
                const res = await fetch('http://localhost:8000/coords', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    const txt = await res.text();
                    throw new Error(txt || res.statusText);
                }
                const data = await res.json();
                console.log('Respuesta Julia:', data);

                simulation = true;
                animar();
            } catch (err) {
                console.error(err);
                alert('Error al enviar a Julia: ' + err.message);
            }
        });

        function resizeCanvas() {
            // Chequeo de seguridad por si el elemento padre aún no cargó
            if(canvas.parentElement) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function dibujarGrid(datos){
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const n = datos.n; 
            const widthCell = canvas.width / n;
            const heightCell = canvas.height / n;

            // --- PINTAR REFRACTADOS (CYAN) ---
            ctx.fillStyle = "cyan";
            datos.refracted.forEach(coord => {
                // Julia envía [fila, columna] empezando en 1
                // JS dibuja en (x, y) empezando en 0
                // Por tanto: x = columna - 1, y = fila - 1
                const fila = coord[0];
                const col = coord[1];
                
                const x = (col - 1) * widthCell;
                const y = (fila - 1) * heightCell;
                
                ctx.fillRect(x, y, widthCell, heightCell);
            });

            // --- PINTAR EXCITADOS (ORANGE) ---
            ctx.fillStyle = "orange";
            datos.excited.forEach(coord => {
                const fila = coord[0];
                const col = coord[1];
                
                const x = (col - 1) * widthCell;
                const y = (fila - 1) * heightCell;
                
                ctx.fillRect(x, y, widthCell, heightCell);
            });
        }

    </script>
</body>
</html>